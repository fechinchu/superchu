# JVM详解08-类的加载过程

# 1.类的加载概述

按照Java虚拟机规范,从class文件到加载到内存中的类,到类卸载出内存位为止,整个生命周期有如下七个阶段;

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20211028153741817.png" alt="image-20211028153741817" style="zoom: 50%;" />

从程序中类的使用过程看如下:

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20211028154033775.png" alt="image-20211028154033775" style="zoom: 50%;" />

# 2.加载Loading

将Java类的字节码文件加载到机器内存中,并在内存中构建出Java类的原型----类模板对象.所谓类模板对象,其实就是Java类在JVM内存中的一个快照,JVM将从字节码文件中解析出常量池,类字段,类方法等信息存储到类模板中.

反射机制即基于这一基础,如果JVM没有将Java类的声明信息存储起来,那么JVM在运行期也无法反射;

在加载类时候,Java虚拟机必须完成以下3件事:

* 通过类的全名,获取类的二进制数据流;
* 解析内的二进制数据流为方法区内的数据结构(Java类模型);
* 在堆中创建`java.lang.Class`类的实例,表示该类型,作为方法区这个类的各种数据的访问入口;

## 2.1.类模型与Class实例的位置

* 类模型的位置:加载的类在JVM中创建相应的类结构,类结构会存储在方法区;
* 在将`.class`文件加载到元空间之后,会在堆中创建一个`Java.lang.Class`对象,用来封装类位于方法区内的数据结构,该Class对象是在加载类的过程中创建的,每个类都对应有一个Class类型的对象;
* `java.lang.Class`实例是访问类型元数据的解耦,也是实现反射的关键数据,入口,通过Class类型提供的接口,可以获得目标类所关联的`.class`文件中具体的数据结构,方法,字段等信息;  

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20211028160928168.png" alt="image-20211028160928168" style="zoom:50%;" />

# 3.链接Linking

## 3.1.验证Verification

当类加载到系统后,就开始链接操作,验证是链接操作的第一步.**它的目的是保证加载的字节码是合法,合理并符合规范**

验证的步骤非常复杂,要验证的项目很繁多,大体上需要做以下验证:

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20211028163131259.png" alt="image-20211028163131259" style="zoom:50%;" />

* 验证的内容涵盖了类数据信息的格式验证,语义检查,字节码验证以及符号引用验证;
  * **格式验证会和加载阶段一起执行**.验证通过后,类加载器才会成功将类的二进制数据信息加载到方法区;
  * **格式验证之外的验证操作将会在方法区中进行**;
  * 符号引用验证在解析环节才会执行;

## 3.2.准备preparation

**为类的静态变量分配内存,并将其初始化为默认值;**

| 类型      | 默认初始值 |
| :-------- | :--------- |
| byte      | (byte)0    |
| short     | (short)0   |
| int       | 0          |
| long      | 0L         |
| float     | 0.0f       |
| double    | 0.0        |
| char      | \u0000     |
| boolean   | false      |
| reference | null       |

* **这里不包含基本数据类型的字段用static final修饰的情况,因为final在编译的时候就会分配,准备阶段就会显式赋值**;
* 这里不会为实例变量分配初始化,类变量会分配在方法区中,而实例变量是会随着对象一起分配到Java堆中;

## 3.2.解析Resolution

**将类,接口,字段和方法的符号引用转化为直接引用;  **

# 4.初始化Initialization

* **为类的静态变量赋予正确的初始值;**

* 类的初始化是类装载的最后一个阶段.如果前面的步骤都没有问题,那么表示类可以顺利装载到系统中.此时,类才会开始执行Java字节码.(到了初始化阶段,才开始真正执行类中定义的Java代码);
* **初始化阶段的重要工作是执行类的初始化方法`<clinit>()`方法**;
  * 该方法仅能由Java编译器生成并由JVM调用,程序开发者无法自定义一个同名的方法,更无法直接在Java程序中调用该方法,虽然该方法也是由字节码指令组成;
  * 它是由类静态成员的赋值语句以及static语句块合并产生的;
* 在加载一个类之前,虚拟机总是会视图加载该类的父类,因此父类的`<clinit>()`总是在子类`<clinit>()`之前被调用.也就是说,父类的static块优先级高于子类;
* Java编译器并不会为所有的类都产生`<clinit>()`初始化方法;

## 4.1.准备阶段与初始化阶段赋值对比

~~~java
/**
 *
 * 说明：使用static + final修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？
 * 情况1：在链接阶段的准备环节赋值
 * 情况2：在初始化阶段<clinit>()中赋值
 *
 *
 * 结论：
 * 在链接阶段的准备环节赋值的情况：
 * 1. 对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行
 * 2. 对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行
 *
 * 在初始化阶段<clinit>()中赋值的情况：
 * 排除上述的在准备环节赋值的情况之外的情况。
 *
 *
 * 最终结论：使用static + final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行。
 */
public class InitializationTest2 {
    public static int a = 1;//在初始化阶段<clinit>()中赋值
    public static final int INT_CONSTANT = 10;//在链接阶段的准备环节赋值

    public static final Integer INTEGER_CONSTANT1 = Integer.valueOf(100);//在初始化阶段<clinit>()中赋值
    public static Integer INTEGER_CONSTANT2 = Integer.valueOf(1000);//在初始化阶段<clinit>()中赋值

    public static final String s0 = "helloworld0";//在链接阶段的准备环节赋值
    public static final String s1 = new String("helloworld1");//在初始化阶段<clinit>()中赋值

    public static String s2 = "helloworld2";

    public static final int NUM1 = new Random().nextInt(10);//在初始化阶段<clinit>()中赋值
}
~~~

## 4.2`<clinit>()`的线程安全性

* 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确地加锁,同步;
* 如果之前的线程成功加载了类,那么等在队列中的线程就没有机会再执行`<clinit>()`方法了.当需要使用这个类时候,虚拟机会直接返回给它已经准备好的信息;

## 4.3.是否能够初始化

**主动使用会调用`<clinit>()`方法,被动使用不会调用,但它们还是类还是会被加载的,区别只是有没有初始化**;

### 4.3.1.主动使用

Class只有在必须要首次使用的时候才会被装载,Java虚拟机不会无条件地装载Class类型.Java虚拟机规定,一个类或接口在初次使用前,必须要进行初始化.这里的使用是指主动使用.主动使用只有下列几种情况;

* 当创建一个类的实例时,比如使用new关键字,或者通过反射,克隆,反序列化;
* 当调用类的静态方法时,即当使用了字节码`invokestatic`指令;
* 当使用类,接口的静态字段(final修饰特殊考虑),比如使用`getstatic`和`putstatic`指令.对应访问变量,赋值变量操作;
* 当初始化子类时候,如果发现其父类还没有进行过初始化.需要先触发其父类的初始化(不适用于接口,初始化一个类,并不会先初始化它所实现的接口);
  * 只有当程序首次使用特定接口的静态字段,才会导致该接口初始化;
* 如果一个接口定义了default方法,那么直接实现或者间接实现该接口的类的初始化.该接口要在其之前被初始化;
* 当虚拟机启动时候,用户需要指定一个要执行的主类(包含`main()`方法的类),虚拟机会优先初始化这个类;
* 当除此调用`MethodHandle`实例,初始化该`MethodHandle`指向方法所在的类;

###4.3.2.被动使用

除了上述的情况属于主动使用,其他情况均属于被动使用.被动使用不会引起类的初始化.

* 当访问一个静态字段时,只有真正声明这个字段的类才会被初始化;
  * 当通过子类引用父类的静态变量,不会导致子类的初始化;
* 通过数组定义类的引用,不会触发此类的初始化;
* 引用常量不会触发此类的接口和初始化,因为常量已经在链接阶段就已经被显示的赋值了;
* 调用`ClassLoader`类的`loadClass()`方法加载一个类,并不是对类的主动使用,不会导致类的初始化; 

# 5.卸载Unloading

## 5.1.类,类的加载器,类的实例之间的引用关系

* 在类加载器内部的实现中,用一个Java集合来存放所加载类的引用.另一方面,一个Class对象总是会引用它的类加载器,调用Class对象的`getClassLoader()`方法,就能获取它的类加载器.代表某个类的Class实例与其类的加载器之间双向关联;
* 一个类的实例总是引用代表这个类的Class对象,在Object类中定义了`getClass()`方法,这个方法返回代表对象所属类的Class对象的引用.此外,所有的Java类都有一个静态属性class.它引用代表这个类的Class对象;

![image-20211029114203231](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20211029114203231.png)

 

## 5.2.类的生命周期

当Sample类被加载,链接,初始化后,它的生命周期就开始了.当代表Sample类的Class对象不再被引用,即不可触及时,Class对象就会结束生命周期,Sample类在方法区内的数据也会被卸载,从而结束Sample类的生命周期;

**一个类何时结束生命周期,取决于代表它的Class对象何时结束生命周期**;

判断一个类型是否属于”不再被使用的类”条件比较苛刻,需要**同时满足**三个条件:

- 该类所有的实例都已经被回收,也就是Java堆中不存在该类及其任何派生子类的实例;
- 加载该类的类加载器已经被回收,很难达成;
- 该类对应的Class对象没有在任何地方被引用,无法在任何地方通过反射反射访问该类的方法;