# JVM优化02

# 1.垃圾回收的常见算法

自动化的管理内存资源,垃圾回收机制必须要有一套算法进行计算,哪些是有效的对象,哪些是无效的对象,对于无效的对象就要进行回收处理.

常见的垃圾回收算法有:引用计数法,标记清除法,标记压缩法,复制算法,分代算法等;

## 1.1.引用计数算法

引用计数是历史最悠久的一种,最早George E.Collins在1960的时候首次提出,50年后的今天,该算法依然被很多编程语言使用.

### 1.1.1.原理

假设有一个对象A,任何一个对象对A的引用,那么对象A的引用计数器+1,当引用失败时,对象A的引用计数器就-1,如果对象A的计数器的值为0,就说明对象A没有引用了,可以被回收.

### 1.1.2.优缺点

优点:

* 实时性较高,无需等到内存不够的时候,运行时根据对象的计数器是否为0,就可以直接回收;
* 在垃圾回收的过程中,应用无需挂起,如果申请内存,内存不足,则立即报OOM错误;
* 区域性,更新对象的计数器,只是影响到该对象,不会扫描全部对象;

缺点:

* 每次对象被引用时,都需要去更新计数器,有一点时间开销;
* 浪费CPU资源,即使内存够用,仍然在运行时进行计数器的统计;
* 无法解决循环引用问题;(致命问题)

## 1.2.标记清除算法

标记清除算法,是将垃圾回收分为2个阶段,分别是标记和清除;

* 标记:从根节点开始标记引用的对象;
* 清除:未被标记引用的对象就是垃圾对象,可以被清理;

### 1.2.1.原理

![image-20200524151750104](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200524151750104.png)

这张图代表的是程序运行期间所有对象的状态,它们的标志位全部是0(也就是未标记,以下默认0就是未标记,1为已标记),假设这会儿有效内存空间耗尽了,JVM将会停止应用程序的运行并开启GC线程,然后开始进行标记工作,按照根搜索算法,标记完以后,对象的状态如下图.

![image-20200524152012885](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200524152012885.png)

可以看到,按照根搜索算法,所有从root对象可达的对象就被标记为了存活的对象,此时已经完成了第一阶段标记.接下来,就要执行第二阶段清除了,那么清除完以后,剩下的对象以及对象的状态如下图:

![image-20200524152221851](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200524152221851.png)

可以看到,没有被标记的对象将会回收清除掉,而被标记的对象将会留下,并且会将标记重新归0,接下来就不用说了,唤醒停止的程序线程,让程序继续运行即可.

### 1.2.2.优缺点

可以看到,标记清除算法解决了引用计数算法中的循环引用的问题,没有从root节点引用的对象都会被回收.

同样标记清除算法也是有缺点的:

* 效率较低,标记和清除两个动作都需要遍历所有的对象,并且在GC时,需要停止应用程序,对于交互性要求比较高的应用而言这个体验非常差;
* 通过标记清除算法清理出来的内存,碎片化比较严重,因为被回收的对象可能存在于内存的各个角落.所以清理出来的内存是不连贯的;

## 1.3.标记压缩算法

标记压缩算法是在标记清除算法的基础上,做了优化改进的算法.和标记清除的算法一样,也是从根节点开始,对对象的引用进行标记,在清理阶段,并不是简单的清理未标记的对象,而是将存活的对象压缩到内存的一端.然后清理边界以外的垃圾,从而解决碎片化问题.

### 1.3.1.原理

![image-20200524153829297](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200524153829297.png)

### 1.3.2.优缺点

优缺点同标记清除算法,解决了标记清除算法的碎片化的问题,同时,标记压缩算法多了一步,对象移动内存位置,其效率也有一定的影响.

## 1.4.复制算法

复制算法的核心就是,将原有的内存空间一分为二,每次只用其中的一块,在垃圾回收时,将正在使用的对象复制到另一个内存空间中,然后将该内存空间清空,交换两个内存的角色,完成垃圾的回收.

如果内存中的垃圾对象较多,需要复制的对象就较少,这种情况下适合使用该方式并且效率比较高.反之,则不适合.

![image-20200524154301289](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200524154301289.png)

### 1.4.1.JVM中年轻代内存空间

![image-20200524162039118](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200524162039118.png)

1. 在GC开始的时候,对象只会存在于Eden区和名为"From"的Survivor区,Survivor区"To"是空的;
2. 紧接着进行GC,Eden去中所有存活的对象都会被复制到"To",而在"From"区中,仍存活的对象会根据他们的年龄值来决定去向,年龄达到一定值(年龄阈值,可以通过`-XX:MaxTenuringThreshold`来设置)的对象会被移动到老年代中,没有达到阈值的对象会被复制到"To"区域;
3. 经过这次GC,Eden区和From区已经被清空.这个时候,"From"和"To"会交换他们的角色,也就是新的"To"就是上次GC前的"From",新的"From"就是上次GC前的"To",不管怎样,都会保证名为To的Survivor区域是空的;
4. GC会一直重复这样的过程,直到"To"区被填满之后,会将所有对象移动到年老代中;

### 1.4.2.优缺点

优点:

* 在垃圾对象多的情况下,效率较高;
* 清理后,内存无碎片;

缺点:

* 在垃圾对象少的情况下,不适用,如:老年代内存;
* 分配的2块内存空间,在同一时刻,只能使用一半,内存使用率较低;

## 1.5.分代算法

分代算法其实是这样:根据回收对象的特点进行选择,在jvm中,年轻代适合使用复制算法,老年代适合使用标记清除或标记压缩算法;

# 2.垃圾收集器以及内存分配

在JVM中,实现了多种垃圾收集器,包括串行垃圾收集器,并行垃圾收集器,CMS(并发)垃圾收集器,G1垃圾收集器;

## 2.1.串行垃圾收集器

串行垃圾收集器,是指使用单线程进行垃圾回收,垃圾回收时,只有一个线程在工作,并且java应用中的所有线程都要暂停,等待垃圾回收的完成.这种现象称之为STW(Stop The World);对于交互性强的应用而言,这种垃圾收集器是不能接受的;一般在Javaweb应用中是不会采用该收集器的;

### 2.1.1.设置垃圾回收为串行收集器

在程序运行参数中添加2个参数,如下:

* `-XX:+UseSerialGC`
  * 指定年轻代和老年代都使用串行垃圾收集器;
* `-XX:+PrintGCDetails`
  * 打印垃圾回收的详细信息

启动程序,可以看到下面信息

![image-20200524164929277](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200524164929277.png)

* DefNew
  * 表示使用的是串行垃圾收集器;
* 4416K->512K(4928K)
  * 表示年轻代GC前,占有4416K内存,GC后,占有512K内存,总大小为4928K;
* 0.0046102 secs
  * 表示GC所用的时间,单位为毫秒;
* 4416K->1973K(15872K)
  * 表示GC前,堆内存占有4416K,GC后,占有1973K,总大小为15872K;
* Full GC
  * 表示,内存空间全部进行GC;

## 2.2.并行垃圾收集器

并行垃圾收集器在串行垃圾收集器的基础之上做了改进,将单线程改为了多线程进行垃圾回收,这样可以缩短垃圾回收时间;

当然了,并行垃圾收集器在收集的过程中也会暂停应用程序,这个核串行垃圾回收器是一样的,只是并行执行,速度更快些,暂停的时间更短一些;

### 2.2.1.ParNew垃圾收集器

ParNew垃圾收集器是工作在年轻代上的,只是将串行垃圾收集器改为了并行;

通过`-XX:+UseParNewGC`参数设置年轻代使用ParNew回收期,老年代使用的依然是串行收集器;

![image-20200524165908299](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200524165908299.png)

### 2.2.2.ParallelGC垃圾收集器

ParallelGC收集器工作机制和ParNewGC收集器一样,只是在此基础之上,新增了两个和系统吞吐量相关的参数,使得其使用起来更加的灵活高效;

相关参数如下:

* `-XX:+UseParallelGC`
  * 年轻代使用ParallelGC垃圾回收期,老年代使用串行回收器;
* `-XX:+UseParallelOldGC`
  * 年轻代使用ParallelGC垃圾回收器,老年代使用ParallelOldGC垃圾回收器;
* `-XX:MaxGCPauseMillis`
  * 设置最大的垃圾收集时的停顿时间,单位为毫秒;
  * 需要注意的是,ParallelGC为了达到设置的停顿时间,可能会调整堆大小或其他参数,如果堆的大小设置的较小,就会导致GC工作变得很繁忙,反而可能会影响到性能;
  * 该参数设置需要谨慎;
* `-XX:GCTimeRatio`
  * 设置垃圾回收时间占程序运行时间的百分比,公式为1/(1+n);
  * 它的值为0-100之间的数值,默认值是99,也就是垃圾回收时间不能超过1%;
* `-XX:UseAdaptiveSizePolicy`
  * 自适应GC模式,垃圾回收器将自动调整年轻代,老年代等参数,达到吞吐量,堆大小,停顿时间之间的平衡;
  * 一般用于,手动调整参数比较困难的场景,让收集器自动进行调整;

![image-20200524171008756](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200524171008756.png)

## 2.3.CMS垃圾收集器

CMS全称Concurrent Mark Sweep,是一款并发的,使用标记,清除算法的垃圾回收器,该回收器是针对老年代垃圾回收的,通过参数`-XX:+UseConcMarkSweepGC`进行设置;

![image-20200524171442933](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200524171442933.png)

* 初始化标记(CMS-initial-mark),标记root,会导致stw;
* 并发标记(CMS-concurrent-mark),与用户线程同时运行;
* 预清理(CMS-concurrent-preclean),与用户线程同时运行;
* 重新标记(CMS-remark),会导致stw;
* 并发清除(CMS-concurrent-sweep),与用户线程同时进行;
* 调整堆大小,设置CMS在清理之后进行内存压缩,目的是清理内存中的碎片;
* 并发重置状态等待下次CMS的触发(CMS-concurrent-reset),让用户线程同时运行;

![image-20200524171859148](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200524171859148.png)

## 2.4.G1垃圾收集器

G1垃圾收集器是在jdk1.7中正式使用的全新的垃圾收集器,Oracle官方计划在JDK9中将G1变成默认的垃圾收集器,用来替代CMS;

G1的设计原则是简化JVM性能调优,开发人员只需要简单的三步即可完成调优;

1. 第一步,开启G1垃圾收集器;
2. 第二步,设置堆的最大内存;
3. 第三步,设置最大的停顿时间;

G1中提供了三种模式垃圾回收模式,Young GC,Mixed GC和Full GC,在不同的条件下被触发;

### 2.4.1.原理

G1垃圾收集器相对比其他收集器而言,最大的区别在于它取消了年轻代,老年代的物理划分,取而代之的是将堆划分为若干个区域(Region),这些区域包含了有逻辑上的年轻代,老年代区域;

这样做的好处就是,我们再也不用单独的空间对每个代进行设置了,不用担心每个代内存是否足够.

![image-20200524213859774](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200524213859774.png)

在G1划分的区域中,年轻代的垃圾收集依然采用暂停所有应用线程的方式,将存活对象拷贝到老年代或者Survivor空间,G1收集器通过将对象从一个区域复制到另一个区域,完成清理工作;

这就意味着,在正常的处理过程中,G1完成了堆的压缩(至少是部分堆的压缩),这样也就不会有cms内存碎片问题的存在了;

在G1中,有一种特殊的区域,叫Humongous区域;

* 如果一个对象占用的空间超过了分区容量50%以上,G1收集器就认为这是一个巨型对象;
* 这些巨型对象,默认直接会被分配在老年代,但是如果是一个短期存放的巨型对象,就会对垃圾收集器造成负面影响;
* 为了解决这个问题,G1划分了一个Humongous区;它用来专门存放巨型对象.如果一个H区装不下一个巨型对象,那么G1会寻找连续的H分区来存储,为了能找到连续的H区,有时候不得不启动Full GC;

### 2.4.2.Young GC

Young GC主要是对Eden区进行GC,它在Eden空间耗尽时会被触发.

* Eden空间的数据移动到Survivor空间中,如果Survivor空间不够,Eden空间的部分数据会直接晋升到老年代空间;
* Survivor区的数据移动到新Survivor区中,也有部分数据晋升到老年代空间中;
* 最终Eden空间的数据为空,GC停止工作,应用线程继续执行;

![image-20200524215805108](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200524215805108.png)

![image-20200524215813626](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200524215813626.png)

#### 2.4.2.1.Remembered Set(已记忆集合)

在GC年轻代的对象时候,我们如何找到年轻代中对象的根对象呢?

根对象可能实在年轻代中,也可以在老年代中,那么老年代中的所有对象都是根么?

如果全量扫描老年代,那么这样扫描下来会耗费大量时间.

于是,G1引入了Rset的概念,它的全称是Remembered Set,其作用是跟踪指向某个堆内的对象引用.

![image-20200524220408973](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200524220408973.png)

每个Region初始化时,会初始化一个RSet,该集合用来记录并跟踪其他Region指向该Region中对象的引用,每个Region默认按照512KB划分为多个Card,所以RSet需要记录的东西应该是XX Region的xx Card;

### 2.4.3.Mixed GC

当越来越多的对象晋升到老年代old region时,为了避免堆内存被耗尽,虚拟机还会触发一个混合的垃圾收集器,即Mixed GC,该算法并不是一个Old GC,除了回收整个Young Region,还会回收一部分的Old Region,这里需要注意:是一部分老年代,而不是全部老年代,可以选择哪些old region进行收集,从而可以对垃圾回收的耗时时间进行控制,也要注意的是Mixed GC并不是Full GC;

MixedGC什么时候触发?由参数`-XX:InitiatingHeapOccupancyPercent=n`决定,默认是:45%,该参数的意思是:当老年代大小占整个堆大小百分比达到该阈值的时候触发;

它的GC步骤分为2步骤:

1. 全局并发标记(global concurrent marking);
2. 拷贝存活对象(evacuation);

#### 2.4.3.1.全局并发标记

全局并发标记,执行过程分为五个步骤:

* 初始标记(initIal mark,STW)
  * 标记从根节点直接可达的对象,整个阶段会执行一次年轻代GC,会产生全局停顿;
* 根区域扫描(root region scan)
  * G1 GC在初始标记的存活区扫描对老年代的引用,并标记被引用的对象;
  * 该阶段与应用程序(非STW)同时运行,并且只有完成该阶段后,才能开始下一次STW年轻代垃圾回收;
* 并发标记(Concurrent Marking)
  * G1 GC在整个堆中查找可访问的(存活的)对象.该阶段与应用程序同时运行,可以被STW年轻代垃圾回收中断;
* 重新标记(Remark,STW)
  * 该阶段是STW回收,因为程序正在运行,针对上一次的标记进行修正;
* 清除垃圾(Cleanup,STW)
  * 清点和重置标记状态,该阶段会STW,这个阶段并不会实际上去垃圾回收,等待evacuation阶段来回收;
* 清除垃圾(Cleanup,STW)
  * 清点和重置标记状态,该阶段会STW,这个阶段并不会实际上做垃圾的收集,等待evacuation阶段来回收.

#### 2.4.3.2.拷贝存活对象

Evacuation阶段是全暂停的.该阶段把一部分Region里的活对象拷贝到另一部分Region中,从而实现垃圾回收清理;

### 2.4.4.G1收集器相关参数

![image-20200524225156892](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200524225156892.png)

### 2.4.5.测试

![image-20200524225242782](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200524225242782.png)

### 2.4.6.对于G1垃圾收集器优化建议

* 年轻代大小
  * 避免使用`-Xmn`选项或`-XX:NewRatio`等其他相关选项显式设置年轻代大小;
  * 固定年轻代的大小会覆盖暂停时间目标;
* 暂停时间目标不要太过严苛
  * G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间;
  * 评估G1 GC的吞吐量时候,暂停时间目标不要太严苛,目标太过严苛表示愿意承受更多的垃圾回收开销,而这会直接影响到吞吐量;

# 3.可视化GC日志分析工具

## 3.1.GC日志输出参数

前面通过`-XX:+PrintGCDetails`可以对GC日志进行打印,我们就可以在控制台查看,这样虽然可以查看GC的信息,但是并不直观,可以借助于第三方的GC日志分析工具进行查看;

![image-20200524231749343](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200524231749343.png)

运行后就可以在自己设置的目录下看到gc.log文件

## 3.2.GC Easy可视化工具

http://gceasy.io/

