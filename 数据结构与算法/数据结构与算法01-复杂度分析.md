# 数据结构与算法01-复杂度分析

## 1.为什么需要进行复杂度分析?

我们可以把代码跑一遍,通过统计监控就能得到算法执行的时间和占用内存大小,为什么还要做时间空间复杂度分析呢?这种分析方法能比我实实在在跑一遍得到的数据更准确吗?

这种评估算法执行效率的方法是正确的.很多数据结构和算法书籍还给这种方法起了一个名字,叫**事后统计法**.但是,这种统计方法有非常大的局限性.

1. 测试结果非常依赖测试环境;
2. 测试结果受数据规模影响很大;

所以,我们需要一个不用具体的测试数据来测试,就可以粗略地估计算法的执行效率的方法,就是**时间空间复杂度分析**的方法;

## 2.大O复杂度表示法

![image-20200706141223350](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200706141223350.png)

假设每个语句的执行时间是unit time.那么这段代码的总执行时间T(n)就可以用如下思路计算:

第2,3,4行代码,每行都需要1个unit time的执行时间,第5,6行代码循环执行了n遍,需要2n unit time的执行时间,第7,8行代码循环执行了n²遍,所以需要2n² unit time的执行时间.所以,整段代码的总执行时间T(n)=(2n²+2n+3)unit time;

总结成规律如下:`T(n)=O(f(n))`;T(n)表示代码执行的时间;n表示数据规模的大小;f(n)表示每行代码执行的次数的综合.因为这是一个公式,所以用f(n)来表示.公司中的O,表示代码的执行时间T(n)与f(n)表达式成正比;上述例子`T(n)=O(2n²+2n+3)`.这就是大O时间复杂度表示法.大O时间复杂度实际上并不具体表示代码真正的执行时间,而是表示**代码执行时间随数据规模增长的变化趋势**.所以,也叫做**渐进时间复杂度**,简称**时间复杂度**;

当n很大时候,可以把它想象成1000000.而公式中的低阶,常量,系数三部分并不左右增长趋势,所以都可以忽略.我们只需要记录一个最大量级就可以了,上述公式可以简化为`T(n)=O(n²)`;

> 大O时间复杂度表示法:
>
> * 只表示数据规模n很大时候的执行效率;
> * 忽略低阶,常量,系数,只保留最高"量级";
> * 表示执行时间随数据规模的增长趋势,而不是具体的执行时间;
> * 实际上,时间复杂度跟执行次数最多的那段代码的执行次数成正比;

## 3.时间复杂度分析

1. 只关注循环执行次数最多的一段代码;

2. 加法法则:总复杂度等于量级最大的那段代码的复杂度;

3. 乘法法则:嵌套代码的复杂度等于嵌套内外代码复杂度的乘积;

   ![image-20200706145129448](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200706145129448.png)

   我们单独的cal()函数,假设f()只是一个普通的操作,那么 4-6行的时间复杂度就是`T1(n)=O(n)`.但f()的函数本身不是一个简单的操作,它的时间复杂度是`T2(n)=O(n)`,所以整个cal()函数时间复杂度就是`T(n)=T1(n)*T2(n)=O(n*n)=O(n²)`;

## 4.几种常见时间复杂度实例分析

![image-20200706145620899](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200706145620899.png)

对于罗列的复杂度量级,我们可以粗略地分为两类,**多项式量级**和**非多项式量级**.其中,非多项式量级只有两个:O($2^{n}$)和O(n!);多项式量级就是这个时间复杂度是由n作为底数的O(n),O(nlogn),非多项式量级就是n不是作为底数O($2^{n}$)指数级;

我们把时间复杂度为非多项式量级的算法问题叫做NP(Non-Deterministic Polynomial,非确定多项式)问题;

当数据规模n越来越大时候,非多项式量级算法的执行时间会急剧增加,求解问题的执行时间会无限增长.所以,非多项式时间复杂度的算法其实是非常低效的算法.

![image-20200706155142955](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200706155142955.png)

### 4.1.O(1)

首先必须明确一个概念,O(1)只是常量级时间复杂度的一种表示方法,并不是指只执行了一行代码.只要代码的执行时间不随着n的增大而增大,这样代码的时间复杂度都记作O(1).或者说,一般情况下,只要算法中不存在循环语句,递归语句,即使有成千上万行的代码,时间复杂度也是O(1);

### 4.2.O(logn),O(nlogn)

![image-20200706153613182](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200706153613182.png)

从代码中可以看出,变量i的值从1开始取,每循环一次就乘以2.当大于n时,巡皇结束.实际上,变量i的取值就是一个等比数列.如果一个一个列出来就会是这样子:

![image-20200706153822185](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200706153822185.png)

$n=2^{X}$得到x=log2n,这段代码的时间复杂度就是O(log2n);

![image-20200706154007243](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200706154007243.png)

归并排序,快速排序的时间复杂度都是O(nlogn);

### 4.3.O(m+n),O(m*n)

~~~java
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
~~~

m和n表示两个数据规模,无法事先评估m和n谁的量级大.在表示复杂度的时候,不能简单的省略,时间复杂度就是O(m+n);

## 5.空间复杂度分析

空间复杂度全称就是**渐进空间复杂度(asymptotic space complexity)**,表示算法的存储空间与数据规模增长关系;

![image-20200706154617127](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200706154617127.png)

我们可以看到,第2行代码中,我们申请了一个空间存储变量i,但它是常量阶的,与数据规模n没有关系,所以我们可以忽略.第3行申请了一个大小为n的int类型数组,除此之外,剩下的代码都没有占用更多的空间,所以整段代码的空间复杂度就是O(n);

空间复杂度实际上表示的是一个峰值,表示的是最高的时候占用的空间;

常见的空间复杂度就是O(1),O(n),O($n^2$),O(logn),O(nlogn)这样的对数阶复杂度平时都用不到.

## 6.最好,最坏情况时间复杂度

![image-20200706161308502](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200706161308502.png)

因为,要查找的变量x可能出现在数组的任意位置.如果数组中第一个元素正好是要查找的变量x,那就不需要继续遍历剩下的n-1个数据了,那时间复杂度就是O(1).但如果数组中不存在变量x,那我们就需要把整个数组都遍历一遍,时间复杂度就成了O(n).所以,不同的情况下,这段代码的时间复杂度是不一样的.

## 7.平均情况时间复杂度

最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度,发生的概率其实并不大.引入另一个概念:平均情况时间复杂度简称为平均时间复杂度.

要查找的变量x在数组中的位置,有n+1种情况:在数组的0~n-1位置中和不在数组中.我们把每种情况下,查找需要遍历的元素个数累加起来,然后再除以n+1,就可以得到需要遍历的元素个数的平均值,即:

![image-20200706163936934](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200706163936934.png)

把公式简化后,得到的平均时间复杂度就是O(n).

然而,我们知道,要查找的变量x,要么在数组里,要么不在数组里.这两种情况对应的概率统计起来很麻烦,为了方便理解,假设在数组中与不在数组中的概率都为1/2.另外,要查找的数据出现在0~n-1这n个位置的概率也是一样的,为1/n.所以,根据概率论乘法法则,要查找的数据出现在0~n-1中任意位置的概率就是1/(2n);

但是,前面的推导过程中没有将各种情况发生的概率考虑进去.如果我们把每种情况发生的概率考虑进去,那平均时间复杂度的计算过程就变成了这样.这个值就是概率论中的**加权平均值**,也叫作**期望值**,所以平均时间复杂度的全称应该叫做**加权平均时间复杂度**或者**期望时间复杂度**;

![image-20200707090445256](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200707090445256.png)

引入概率之后,前面那段代码的加权平均值为(3n+1)/4.用大O表示法来表示,去掉系数和常量,这段代码的加权平均时间复杂度仍然是O(n);

## 8.均摊时间复杂度

均摊时间复杂度是一种特殊的平均情况时间复杂度.它采用的是摊还分析法;

 ![image-20200707112504297](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200707112504297.png)

这段代码实现了往一个数组中插入数据的功能,当数组满了之后,也就是代码中的`count == array.length`时,我们用for循环遍历数组求和.并清空数组,将求和之后的sum值放到数组的第一个位置,然后再将新的数据插入.如果数组一开始就有空闲时间,则直接将数据插入.

假设数组的长度是n,根据数据插入的位置不同,可以分为n种情况,每种情况的时间复杂度是O(1).除此之外,还有一种情况,就是在数组没有空闲时间时插入.这个事件复杂度是O(n).而且,这n+1中情况发生的概率一样.都是`1/(n+1)`.

![image-20210703163235091](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210703163235091.png)

对于insert()函数来说,O(1)时间复杂度的插入和O(n)时间复杂度的插入,出现的频率是非常有规律的,一般都是一个O(n)插入之后,紧跟着n-1个O(1)的插入操作,循环往复.

针对这种特殊场景,我们引入:**摊还分析法**,通过摊还分析得到的实现复杂度叫做均摊时间复杂度.

每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1).

对一个数据结构进行一组连续操作中,大部分情况下时间复杂度都很低,只有个别情况下时间复杂度比较高,而且这些操作之间存在前后连续的时序关系,这个时候,就可以将一组操作放在一块分析,看能否将较高时间复杂度的那次操作平摊到其他时间复杂度低的操作上.而且,在能够应用到均摊时间复杂度分析的场合,**一般均摊时间复杂度就等于最好时间复杂度**.

能够应用摊还分析法分析均摊时间复杂度的代码并不多,常见的就是支持动态扩容的一些数据结构;

