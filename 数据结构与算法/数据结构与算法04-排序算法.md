# 数据结构与算法04-排序算法

# 1.排序算法简介

排序算法很多多,有很多连名字都没听说过.最经典,最常用的:冒泡排序,插入排序,选择排序,归并排序,快速排序,计数排序,基数排序,桶排序.按照时间复杂度将它们分为三类;

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210809215108451.png" alt="image-20210809215108451" style="zoom: 50%;" />

## 1.1.分析排序算法

### 1.1.1.排序算法的时间复杂度

#### 1.1.1.1.最好情况,最坏情况,平均情况时间复杂度

为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。

#### 1.1.1.2.时间复杂度的系数,常数,低阶

时间复杂度反映的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来.

#### 1.1.1.3.比较次数和交换次数

基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。

### 1.1.2.排序算法的空间复杂度

算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序。**原地排序算法，就是特指空间复杂度是 O(1) 的排序算法**。

> 空间复杂度与原地性的关系
>
> * 原地排序算法的空间复杂度并不一定是O(1);
> * 空间复杂度为O(1)的排序算法肯定是原地排序算法;
>
> 比如快排,空间复杂度需要考虑递归调用函数栈的消耗,原地不考虑;

### 1.1.3.排序算法的稳定性

这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变.

如果我们要给电商交易系统中的订单排序.订单有两个属性,一个是下单时间,另一个是订单金额.我们希望按照金额从小到大对订单数据排序.对于金额相同的订单,我们希望按照下单时间从早到晚有序.借助稳定排序算法,这个问题会很简单.思路如下:我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210809220214045.png" alt="image-20210809220214045" style="zoom:50%;" />

# 2.冒泡排序

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210809220406555.png" alt="image-20210809220406555" style="zoom: 67%;" />

可以继续优化,当某次冒泡操作进没有数据可以交换时候,说明已经达到完全有序,不用再继续执行后续的冒泡操作.

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210809220606205.png" alt="image-20210809220606205" style="zoom:67%;" />

代码如下:

~~~java
// 冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
   for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
~~~

* 冒泡排序是原地排序.
  * 因为冒泡只涉及相邻数据的交换操作,只需要常量级的临时空间,空间复杂度是O(1),是一个原地排序算法;
* 冒泡排序时稳定的排序算法
  * 当有相邻的两个元素大小相等的时候,不做交换;

## 2.1.冒泡排序的时间复杂度

* 最好情况时间复杂度:要排序的数据已经是有序的了,只需要进行一次冒泡操作,最好情况时间复杂度是O(n);
* 最坏情况时间复杂度:要排序的数据刚好是倒序排列,需要进行n次冒泡操作,最坏情况时间复杂度是O(n^2);

* 平均时间复杂度就是加权平均期望时间复杂度,分析的时候要结合概率论;
  * 另一种思路是通过"有序度"和"逆序度"进行分析:

### 2.1.1.有序度分析

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210809221927711.png" alt="image-20210809221927711" style="zoom:50%;" />

* 对于一个倒序排列的数组,比如6,5,4,3,2,1.有序读就是0;

* 对于一个完全有序的数组,有虚度就是n*(n-1)/2,这个叫做满有序度;
* **逆序度=满有序度-有序度**;

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210809222939240.png" alt="image-20210809222939240" style="zoom: 67%;" />

冒泡排序包含两个操作,比较和交换,交换一次,有序度就加1.不管算法如何改进,交换次数总是确定的.即为逆序度.也就是`n*(n-1)/2-初始有序度`.上述例子就是15-3=12,要进行12次交换操作;

对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行` n*(n-1)/2 `次交换。最好情况下，初始状态的有序度是` n*(n-1)/2`，就不需要进行交换。我们可以取个中间值 `n*(n-1)/4`，来表示初始有序度既不是很高也不是很低的平均情况。换句话说，平均情况下，需要 `n*(n-1)/4 `次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n^2)，所以平均情况下的时间复杂度就是 O(n^2)。这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太复杂;

* 平均交换次数:`k1 = n*(n-1)/4`;
* 平均比较次数:`k2<n^2 && k2>k1=n*(n-1)/4`;
* 冒泡排序算法平均时间复杂度是`O(k1+k2)=O(n^2)`;

# 3.插入排序

先看一个问题,一个有序的数组,往里面添加一个新的数据后,如何继续保持数据有序?我们只要遍历数组,找到数据应该插入的位置即可将其插入即可;

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210809223935257.png" style="zoom:67%;" />

我们可以通过这种方法保持集合中的数据一直有序.对于一组静态数据,我们也可以借鉴上面的插入方法.就是插入排序;

首先将数组中的数据分为两个区间,**已排序区间**和**未排序区间**.初始已排序区间只有一个元素,就是数组的第一个元素.插入算法的核心思想是取未排序区间中的元素.在已排序区间中找到合适的插入位置将其插入.并保证已排序区间数据一直有序.重复这个过程,直到未排序区间中元素为空.

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210809224304089.png" alt="image-20210809224304089" style="zoom:67%;" />

对于一个给定的初始序列,移动操作的次数总是固定的.就等于逆序度;初始序列的有序度是5,逆序度是10,插入排序中,数据移动的个数总和也等于10=3+4+4;

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210809225052916.png" alt="image-20210809225052916" style="zoom:67%;" />

~~~java
// 插入排序，a表示数组，n表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
~~~

* 原地排序算法:插入排序算法并不需要额外的存储空间,所以空间复杂度是O(1),原地排序算法;
* 稳定的排序算法.对于值相同的元素,可以选择将后面出现的元素,插入到前面出现元素的后面;
* 插入排序的时间复杂度:
  * 最好时间复杂度:有序数组里面查找插入位置,每次只需要比较一个数据就能确定插入的位置.所以最好时间复杂度是O(n);
  * 最坏时间复杂度:每次插入都相当于在数组的第一个位置插入新的数据,需要移动大量数据,最坏时间复杂度O(n^2);
  * 平均时间复杂度:数组插入一个数据的平均时间复杂度是O(n).对于插入排序来说,每次插入操作都相当于在数组中插入一个数据.循环执行n次,所以平均时间复杂度为O(n^2);

## 3.2.冒泡排序VS插入排序

~~~java
//冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

//插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
~~~

我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。

# 4.选择排序

选择排序算法的实现类似于插入排序.分已排序区间和未排序区间.但是选择排序每次都会从未排序区间中找到最小的元素,将其放到已排序区间的末尾

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210809232955810.png" alt="image-20210809232955810" style="zoom:67%;" />

```java
public void selectionSort(int[] a,int n){
  if(n <= 1) return;
  for(int i = 0; i < n-1;i++){
    int minPos = i;
    for(int j = i;j < n;j++){
      if(a[j] < a[minPos]){
        minPos = j;
      }
    }
    //交换元素
    int tmp = a[i];
    a[i] = a[minPos];
    a[minPos] = tmp;  
  }
}
```

* 原地排序算法;
* 最好时间复杂度,最坏时间复杂度,平均时间复杂度都是(n^2);
* 不是稳定的排序算法;

# 5.归并排序

如果要排序一个数组,先把数组从中间分成前后两部分,然后对前后两部分分别排序,再将排好序的两部分合并在一起,这样整个数组就都有序了;

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210809234053110.png" alt="image-20210809234053110" style="zoom: 50%;" />

分治就是将一个大问题分解成小的问题来解决.小的问题解决了,大问题就解决了.

分治是一种解决问题的处理思想,递归是一种编程技巧,分治一般都是用递归来实现的.

递推公式如下:

~~~java
//递推公式：
merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))

//终止条件：
p >= r //不用再继续分解
~~~

代码如下:

~~~java
// 归并排序算法, A是数组，n表示数组大小
merge_sort(A, n) {
  merge_sort_c(A, 0, n-1)
}

// 递归调用函数
merge_sort_c(A, p, r) {
  // 递归终止条件
  if p >= r  then return

  // 取p到r之间的中间位置q
  q = (p+r) / 2
  // 分治递归
  merge_sort_c(A, p, q)
  merge_sort_c(A, q+1, r)
  // 将A[p...q]和A[q+1...r]合并为A[p...r]
  merge(A[p...r], A[p...q], A[q+1...r])
}
~~~

`merge(A[p...r], A[p...q], A[q+1...r])` 这个函数的作用就是，将已经有序的` A[p...q]`和 `A[q+1....r]`合并成一个有序的数组，并且放入` A[p....r]`

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210809235807187.png" alt="image-20210809235807187" style="zoom: 50%;" />

如图所示，我们申请一个临时数组 tmp，大小与 A[p...r]相同。我们用两个游标 i 和 j，分别指向 A[p...q]和 A[q+1...r]的第一个元素。比较这两个元素 A[i]和 A[j]，如果 A[i]<=A[j]，我们就把 A[i]放入到临时数组 tmp，并且 i 后移一位，否则将 A[j]放入到数组 tmp，j 后移一位.继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组 tmp 中的数据拷贝到原数组 A[p...r]中.

代码如下:

~~~java
merge(A[p...r], A[p...q], A[q+1...r]) {
  var i := p，j := q+1，k := 0 // 初始化变量i, j, k
  var tmp := new array[0...r-p] // 申请一个大小跟A[p...r]一样的临时数组
  while i<=q AND j<=r do {
    if A[i] <= A[j] {
      tmp[k++] = A[i++] // i++等于i:=i+1
    } else {
      tmp[k++] = A[j++]
    }
  }
  
  // 判断哪个子数组中有剩余的数据
  var start := i，end := q
  if j<=r then start := j, end:=r
  
  // 将剩余的数据拷贝到临时数组tmp
  while start <= end do {
    tmp[k++] = A[start++]
  }
  
  // 将tmp中的数组拷贝回A[p...r]
  for i:=0 to r-p do {
    A[p+i] = tmp[i]
  }
}
~~~

## 5.1.归并排序的性能分析

### 5.1.1.稳定的排序算法

归并排序稳不稳定关键看`merge()`函数,在合并的过程中,如果 A[p...q]和 A[q+1...r]之间有值相同的元素，那我们可以像伪代码中那样，先把 A[p...q]中的元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法.

### 5.1.2.归并排序的时间复杂度

#### 5.1.2.1.递归公式解法

如果我们定义求解问题a的时间是T(a),求解问题b,c的时间分别是T(b)和T(c),那么我们就可以得到这样的递推关系式:`T(a) = T(b) + T(c) + K`;

我们假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。merge() 函数合并两个有序子数组的时间复杂度是 O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：

~~~
T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。
T(n) = 2*T(n/2) + n； n>1
~~~

分解计算过程如下:

~~~
T(n) = 2*T(n/2) + n
     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
     ......
     = 2^k * T(n/2^k) + k * n
     ......
~~~

通过这样一步一步分解推导，我们可以得到 T(n) = 2^kT(n/2^k)+kn。当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log2n 。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。所以归并排序的时间复杂度是 O(nlogn)

归并排序的执行效率与要排序的原始数组的有序程度无关,所以其时间复杂度稳定,不管是最好情况,最坏情况,时间复杂度都是O(nlogn);

#### 5.1.2.2.递归树解法

![image-20210907204448694](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210907204448694.png)

### 5.1.3.归并排序的空间复杂度

* 递归函数调用栈的空间消耗O(logn);
* 合并操作tmp数组的空间消耗:O(n),任意时间自由一个合并操作在执行;
* 综合上述两部分,归并排序算法的空间复杂度是O(n);

# 6.快速排序

如果要排序数组中下标从p到r之间的一组数据,选择p到r之间的任意一个数据为pivot(区分点);

我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的;

![image-20210810095730824](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210810095730824.png)

根据分治,递归的处理思想,我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了.

递推公式如下:

~~~
递推公式：
quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)

终止条件：
p >= r
~~~

代码如下

~~~java

// 快速排序，A是数组，n表示数组的大小
quick_sort(A, n) {
  quick_sort_c(A, 0, n-1)
}
// 快速排序递归函数，p,r为下标
quick_sort_c(A, p, r) {
  if p >= r then return
  
  q = partition(A, p, r) // 获取分区点
  quick_sort_c(A, p, q-1)
  quick_sort_c(A, q+1, r)
}
~~~

这里有一个 partition() 分区函数。partition() 分区函数实际就是随机选择一个元素作为 pivot（一般情况下，可以选择 p 到 r 区间的最后一个元素），然后对 A[p...r]分区，函数返回 pivot 的下标.如果我们不考虑空间消耗的话，partition() 分区函数可以写得非常简单。我们申请两个临时数组 X 和 Y，遍历 A[p...r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中数据顺序拷贝到 A[p....r]。

![image-20210810103611837](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210810103611837.png)

但是如果这样的话,快排就不是原地排序算法了,原地分区函数的实现代码如下

~~~java
private static int partition(int[] a,int p,int r){
  int i = p-1;//[p,i]表示小于pivot值的元素;
  for(int j = p;j < r;++j){
    if(a[j]<a[r]){
      swap(a,i+1,j);
      i++;
    }
  }
  swap(a,i+1,r);
  return i+1;
}

private void swap(int[] nums,int i,int j){
  int tmp = nums[i];
  nums[i] = nums[j];
  nums[j] = tmp;
}
~~~

这里的处理有点类似选择排序。我们通过游标 i 把 A[p...r-1]分成两部分。A[p...i-1]的元素都是小于 pivot 的，我们暂且叫它“已处理区间”，A[i...r-1]是“未处理区间”。我们每次都从未处理的区间 A[i...r-1]中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i]的位置。

![image-20210810104743876](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210810104743876.png)

因为分区的过程涉及交换操作,快速排序并不是一个稳定的排序算法;

还有一种双指针的算法如下图

![image-20210907225052667](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210907225052667.png)

## 6.1.快速排序的性能分析

### 6.1.1.快速排序的时间复杂度

**最好情况下,分区及其平均**:

如果每次分区都能把正好把大区间分成大小接近的两个小区间,快速排序的时间复杂度递推公式如下:

~~~
T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。
T(n) = 2*T(n/2) + n； n>1
~~~

但是，公式成立的前提是每次分区操作，我们选择的 pivot 都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。

**最坏情况下,分区及其不平均:**

例如L数据1,3,5,7,9.每次都都选择最后一个元素作为pivot,每次分区得到的两个小区间都是很不均等的.需要进行大约n次分区操作.才能完成快排的整个过程.每次分区平均要扫描大约n/2个元素,快速排序时间复杂度从O(nlogn)退化成O(n^2);

**平均时间复杂度**:O(logn).如下图;

### 6.1.2.快速排序的空间复杂度

最好情况下:在分区点选择比较平均的情况,每次分区都将大区间一份为二;所以,递归的最大深度为log2n;空间复杂度是O(logn);

最坏情况下:递归的最大深度为n,空间负责大就是O(n);

平均情况下:O(logn),如下图;

![image-20210907222336040](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210907222336040.png)

## 6.2.归并排序VS快速排序

![image-20210810105424895](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210810105424895.png)

归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题.

# 7.桶排序

核心思想是将要排序的数据分到几个有序的桶里,每个桶的数据再单独进行排序.桶内排完序之后,再把每个桶里的数据按照顺序依次取出,组成的序列就是有序的;

![image-20210810111210236](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210810111210236.png)

如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。

但是,桶排序对要排序的数据的要求非常苛刻:首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。

**桶排序比较适合用在外部排序**.外部排序就是数据存储在外部磁盘中,数据量比较大,内存有限,无法将数据全部加载到内存中;

# 8.计数排序

计数排序其实是桶排序的一种特殊情况.当要排序的n个数据,所处的范围并不大的时候,比如最大值是k,我们就可以把数据划分为k个桶.每个桶内的数据值是相同的,省掉了桶内排序的时间;

如果高考所在的省有50万考生,如果通过成绩快速排序得出名次?考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。

假设有8个考生,分数在0到5分之间,这8个考生的成绩在数组A[8]中,它们分别是2,5,3,0,2,3,0,3;考生成绩从0到5分,使用大小为6的数组C[6]表示桶,其中下标对应分数.

![image-20210810141213713](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210810141213713.png)

我们对C[6]数组顺序求和,C[6]存储的数据变成如下.

![image-20210810141259644](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210810141259644.png)

我们从后到前依次扫描数组A[2,5,3,0,2,3,0,3],当扫描到 3 时，我们可以从数组 C 中取出下标为 3 的值 7，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中下标为 6 的位置）。当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3]要减 1，变成 6;

![image-20210810141533181](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210810141533181.png)

代码如下:

~~~java
// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。
public void countingSort(int[] a, int n) {
  if (n <= 1) return;

  // 查找数组中数据的范围
  int max = a[0];
  for (int i = 1; i < n; ++i) {
    if (max < a[i]) {
      max = a[i];
    }
  }

  int[] c = new int[max + 1]; // 申请一个计数数组c，下标大小[0,max]
  for (int i = 0; i <= max; ++i) {
    c[i] = 0;
  }

  // 计算每个元素的个数，放入c中
  for (int i = 0; i < n; ++i) {
    c[a[i]]++;
  }

  // 依次累加
  for (int i = 1; i <= max; ++i) {
    c[i] = c[i-1] + c[i];
  }

  // 临时数组r，存储排序之后的结果
  int[] r = new int[n];
  // 计算排序的关键步骤，有点难理解
  for (int i = n - 1; i >= 0; --i) {
    int index = c[a[i]]-1;
    r[index] = a[i];
    c[a[i]]--;
  }

  // 将结果拷贝给a数组
  for (int i = 0; i < n; ++i) {
    a[i] = r[i];
  }
}
~~~

**计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数**

如果考生成绩精确到小数后一位，我们就需要将所有的分数都先乘以 10，转化成整数，然后再放到 9010 个桶内。再比如，如果要排序的数据中有负数，数据的范围是[-1000, 1000]，那我们就需要先对每个数据都加 1000，转化成非负整数。

# 9.基数排序

假设有10万个手机号码,希望把10万个手机号码从小到大排序,先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了.这里的排序算法要是稳定的,否则无意义;

![image-20210810142536145](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210810142536145.png)

根据每一位来排序，我们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n).有时候要排序的数据并不都是等长的,可以在后面补齐"0";

基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了;

