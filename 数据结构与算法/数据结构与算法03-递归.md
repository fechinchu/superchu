# 数据结构与算法03-递归与分治

# 1.递归与分治的关系

**分治是一种思想**:分而治之.具体到算法方面,就是将原问题划分成多个规模更小并且结构与原问题相同的子问题,先解决这些子问题,然后再合并其结果,就得到原问题的解;

**递归是一种编程技巧**:一个函数自己调用自己;

递归也具有结构相同,规模不同的特点.所以,涉及到用分治思想解决的问题,也比较合适用递归来实现;

# 2.递归满足的三个条件

你在电影院不知道自己是第几排?可以问前面一排的人是第几排.只要在他数字上加1就知道自己是第几排了.前面的人就接着问前面的人.一排一排的问.直到问到第一排的人.说自己在第一排.然后再一排一排的把数字传回来.

去的过程叫"递",回来的过程叫"归".基本上,所有的递归问题都可以用递推公司来表示.`f(n)=f(n-1)+1 `其中，`f(1)=1`;

递归代码如下所示:

~~~java
int f(int n) {
  if (n == 1) return 1;
  return f(n-1) + 1;
}
~~~

1. 一个问题的解可以分解为几个子问题的解;

   子问题就是数据规模更小的问题."自己在哪一排"可以分解为"前一排的人在哪一排"?

2. 这个问题与分解后的子问题,除了数据规模不一样,求解思路完全一样;

   求解自己在哪一排的思路与前面一排人求解自己在哪一排的思路是一样的;

3. 存在终止条件

   一层一层的传递下去,不能存在无限循环,需要有终止条件.比如上述例子的`f(1)=1`就是递归的终止条件;

> 如何发现一个问题可以用递归来做?
>
> 1. 规模更小的问题,跟规模大的问题,解决思路相同,仅仅规模不同;
> 2. 利用子问题的解可以组合得到原问题的解;
> 3. 存在最小子问题,可以直接返回结果(存在递归终止条件);

# 3.编写递归代码

假设有n级台阶,我们可以每步跨1级台阶或者2级台阶.上n级台阶共有多少种走法.

我们可以根据第一步的走法,把所有的走法分为两类;一类是第一步走了1级台阶,另一类是第一步走了2级台阶.因此,n级台阶的走法就等于第一步走1级台阶后,走剩下的n-1级台阶的走法,加上第一步走2级台阶的走法,走剩下的n-2级台阶的走法.`f(n) = f(n-1)+f(n-2)`;

终止条件可以用n=2这样比较小的数据来试一下.`f(2)=f(1)+f(0)`.除了`f(1)=1`这一个递归终止条件外,还要有`f(0)=1`,表示走0个台阶有一个走法.不过这样子就不符合正常的逻辑思维.所以,我们可以把`f(2)=2`作为一种终止条件,表示走2个台阶,有两种走法;所以终止条件就是`f(1)=1`，`f(2)=2`.

~~~java
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  return f(n-1) + f(n-2);
}
~~~

**对于递归代码,这种视图想理清楚整个递和归过程的做法,实际上是进入了一个思维误区.如果一个问题可以分解为若干子问题B,C,D,可以假设子问题已经解决,在此基础上思考如何解决问题A.而且,你只需要思考问题A与子问题B,C,D两层之间的关系.不需要一层一层往下思考子问题与子子问题.屏蔽掉递归细节,这样子理解起来就简单了.因此，编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。**

# 4.递归代码警惕堆栈溢出

如果递归求解的数据规模很大,调用层次很深,一直压入栈,就会有栈溢出的风险; 

可以通过在代码中限制递归调用的最大深度的方式来解决这个问题.递归调用超过一定深度(比如1000)之后.就不继续往下递归了,直接返回报错,

~~~java
// 全局变量，表示递归的深度。
int depth = 0;

int f(int n) {
  ++depth；
  if (depth > 1000) throw exception;
  
  if (n == 1) return 1;
  return f(n-1) + 1;
}
~~~

但是这种做法并不能完全解决问题,因为最大允许的递归深度跟当前线程剩余的栈空间大小有关;

# 5.递归代码警惕重复计算

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210809194700069.png" alt="image-20210809194700069" style="zoom:50%;" />

为了避免重复计算,我们可通过一个数据结构(比如散列表)来保存已经求解过的f(k).当递归调用f(k)时,先看下是否已经求解过了.如果是,直接从散列表中取值返回.

~~~java
public int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  
  // hasSolvedList可以理解成一个Map，key是n，value是f(n)
  if (hasSolvedList.containsKey(n)) {
    return hasSolvedList.get(n);
  }
  
  int ret = f(n-1) + f(n-2);
  hasSolvedList.put(n, ret);
  return ret;
}
~~~

# 6.将递归代码改写为非递归代码

递归代码有利有弊,利是递归代码的表达力很强,写起来非常简洁;弊就是空间复杂度搞,有堆栈溢出的风险,存在重复计算,过多的函数调用会耗时较多的问题.

电影院的例子改写如下:

~~~java
int f(int n) {
  int ret = 1;
  for (int i = 2; i <= n; ++i) {
    ret = ret + 1;
  }
  return ret;
}
~~~

走楼梯的例子改写如下:

~~~java
int f(int n) {
  if (n == 1) return 1; 
  if (n == 2) return 2;
  
  int ret = 0;
  int pre = 2;
  int prepre = 1;
  for (int i = 3; i <= n; ++i) {
    ret = pre + prepre;
    prepre = pre;
    pre = ret;
  }
  return ret;
}
~~~

其实所有的递归代码都可以改为这种迭代循环的非递归写法.因为递归本身是借助栈来实现的,只不过我们使用的栈是系统或者虚拟机本身提供的,我们没有感知而已.如果我们自己在内存堆上实现栈.手动模拟入栈,出栈过程,这样任何递归代码都可以改写成看上去不是递归代码的样子.但是这种思路实际上是将递归改为了手动递归,本质没有改变,而且没有解决前面讲到的某些问题,徒增复杂度;

# 7.递归代码时间和空间复杂度分析

## 7.1.时间复杂度

递归代码的时间复杂度可以用2种方式进行分析

1. 递归公式(不通用);
2. 递归树(通用);

如下分析以走楼梯为例;

### 7.1.1.递归公式分析

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210906232514567.png" alt="image-20210906232514567" style="zoom: 67%;" />

### 7.1.2.递归树分析

![image-20210906232601304](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210906232601304.png)

## 7.2.空间复杂度

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210906232630103.png" alt="image-20210906232630103" style="zoom: 67%;" />
