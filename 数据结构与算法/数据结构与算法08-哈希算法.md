# 数据结构与算法08-哈希算法

# 1.哈希算法简介

将任意长度的二进制值串映射为固定长度的二进制值串,这个映射的规则就是**哈希算法**.而通过原始数据映射之后得到的二进制值串就是**哈希值**;优秀的哈希算法需要满足如下要求:

* 从哈希值不能反向推导出原始数据(所以哈希算法也叫单向哈希算法);
* 对输入数据非常敏感,哪怕原始数据只修改了一个Bit,最后得到的哈希值也打不相同;
* 散列冲突的概率要很小,对于不同的原始数据,哈希值相同的概率非常小;
* 哈希算法的执行效率要尽量高效,针对较长的文本,也能快速计算出哈希值;

哈希算法的应用非常多,常见有:

* 安全加密;
* 唯一标识;
* 数据效验;
* 散列函数;
* 负载均衡;
* 数据分片;
* 分布式存储;

# 2.应用一:安全加密

最常用于加密的哈希算法是MD5(MD5 Message-Digest Algorithm，MD5 消息摘要算法)和SHA(Secure Hash Algorithm，安全散列算法),还有如DES(Data Encryption Standard，数据加密标准),AES(Advanced Encryption Standard，高级加密标准);

对用于加密的哈希算法来说,两点很重要:

* 从哈希值不能反向推导出原始数据;
* 散列冲突的概率要很小;

对于散列冲突的话,实际上不管什么哈希算法,只能尽量减少碰撞冲突的概率,理论上是没办法做到的.

因为这里涉及到组合数学中一个基础理论,鸽巢原理(抽屉原理).如果有 10 个鸽巢，有 11 只鸽子，那肯定有 1 个鸽巢中的鸽子数量多于 1 个;

哈希算法产生的哈希值的长度是固定且有限的。比如前面的 MD5 的例子，哈希值是固定的 128 位二进制串，能表示的数据是有限的，最多能表示 2^128 个数据，而我们要哈希的数据是无穷的。基于鸽巢原理，如果我们对 2^128+1 个数据求哈希值，就必然会存在哈希值相同的情况。一般情况下，哈希值越长的哈希算法，散列冲突的概率越低。

如果我们拿到一个 MD5 哈希值，希望通过毫无规律的穷举的方法，找到跟这个 MD5 值相同的另一个数据，那耗费的时间应该是个天文数字。所以，即便哈希算法存在冲突，但是在有限的时间和资源下，哈希算法还是很难被破解的。

除此之外，没有绝对安全的加密。越复杂、越难破解的加密算法，需要的计算时间也越长。比如 SHA-256 比 SHA-1 要更复杂、更安全，相应的计算时间就会比较长。密码学界也一直致力于找到一种快速并且很难被破解的哈希算法。我们在实际的开发过程中，也需要权衡破解难度和计算时间，来决定究竟使用哪种加密算法。

# 3.应用二:唯一标识

如果要在海量的图库中,搜索一张图是否存在.我们知道任何文件在计算中都可以标识成二进制码串.我们可以从图片的二进制码串中取一定的直接进行哈希算法,得到一个哈希字符串,作为图片的唯一标识.

如果还想继续提高效率，我们可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。当要查看某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识。如果不存在，那就说明这个图片不在图库中；如果存在，我们再通过散列表中存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样。如果一样，就说明已经存在；如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。

# 4.应用三:数据效验

BT下载电影.我们从多个机器上并行下载一个电影.这个电影文件被分割成很多文件块.等所有的文件都下载完成后,再组装成一个完整的电影文件就可以.

我们通过哈希算法，对 100 个文件块分别取哈希值，并且保存在种子文件中。我们在前面讲过，哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。

# 5.应用四:散列函数

散列函数中用到的散列算法,更加关注散列后的值是否能平均分布.除此之外，散列函数执行的快慢，也会影响散列表的性能，所以，散列函数用的散列算法一般都比较简单，比较追求效率;

# 6.应用五:负载均衡

负载均衡算法有很多，比如轮询、随机、加权轮询等。那如何才能实现一个会话粘滞（session sticky）的负载均衡算法呢？也就是说，需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。

通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。

# 7.应用六:数据分片

假设现在我们的图库中有 1 亿张图片，很显然，在单台机器上构建散列表是行不通的。因为单台机器的内存有限，而 1 亿张图片构建散列表显然远远超过了单台机器的内存上限。我们同样可以对数据进行分片，然后采用多机处理。我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。

# 8.应用七:分布式存储

现在互联网面对的都是海量的数据、海量的用户。我们为了提高数据的读取、写入能力，一般都采用分布式的方式来存储数据，比如分布式缓存。

我们可以借用前面数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。

原来的数据是通过与 10 来取模的。比如 13 这个数据，存储在编号为 3 这台机器上。但是新加了一台机器中，我们对数据按照 11 取模，原来 13 这个数据就被分配到 2 号这台机器上了。因此，所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。这样就相当于，缓存中的数据一下子就都失效了。所有的数据请求都会穿透缓存，直接去请求数据库。这样就可能发生雪崩效应，压垮数据库。

我们通过一致性哈希算法来保证不做大量的数据搬移;

假设我们有 k 个机器，数据的哈希值的范围是[0, MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。