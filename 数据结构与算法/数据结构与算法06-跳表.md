# 数据结构与算法06-跳表

# 1.跳表简介

二分查找算法底层依赖的是数组随机访问的特行,所以只能用数组来实现,我们可以对链表加以改造,就可以支持类似"二分"的查找算法,改造之后的数据结构叫做跳表(Skip list);

跳表是一种各个方面性能比较优秀的动态数据结构,可以支持快速插入,删除,查找操作,甚至可以替代红黑树;

Redis中的Sorted Set就是用跳表来实现的.

对于一个单链表来讲,即便链表中存储的数据是有序的,如果我们要想在其中查找某个数据,也只能从头到尾遍历链表,这样查找效率很很低,时间复杂度搞,是O(n);

![image-20210810165215120](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210810165215120.png)

我们对链表建立一级索引,查找起来就会更快一些.图中的down标识down指针,指向下一级结点;

![image-20210810165251184](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210810165251184.png)

跟前面建立第一级索引的方式相似,我们在第一级索引的基础上,每两个节点就抽出一个结点到第二级索引.

![image-20210810165655600](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210810165655600.png)

以此类推:如下图

![image-20210810165727316](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210810165727316.png)

没有索引的时候,查找62需要遍历62个节点,现在只需要遍历11个结点/

# 2.跳表的性能

## 2.1.跳表查询时间复杂度

在一个单链表中查询某个数据的时间复杂度是O(n);

我们在单链表的基础上,每两个结点抽出一个结点作为上一级索引的结点.第一级索引的结点个数大约是n/2.第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/(2k)。

假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n/(2h)=2，从而求得 h=log2n-1。如果包含原始链表这一层，整个跳表的高度就是 log2n。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。这里的m是3.所以在跳表中查询任意数据的时间复杂度就是O(logn);

![image-20210810170341067](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210810170341067.png)

## 2.2.跳表的空间复杂度

假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。

![image-20210810170855652](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210810170855652.png)

这几级索引的结点总和就是n/2+n/4+n/8…+8+4+2=n-2.所以跳表的空间复杂度是O(n);

## 2.3.跳表插入和删除时间复杂度

在单链表中,一旦定位好插入的位置,插入结点的时间复杂度是很低的,就是O(1).但是,为了保证原始链表中数据的有序性,需要先找到要插入的位置,这个查找操作就会比较耗时;

对于跳表来说,查找某个节点的时间复杂度是O(logn),所以这里查找某个数据应该插入的位置,方法也是类似的,时间复杂度也是O(logn);

![image-20210810172133882](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210810172133882.png)

删除结点的话,除了要删除原始链表中的结点,还要删除索引中的结点.

# 3.跳表的索引动态更新

![image-20210810172727818](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210810172727818.png)

当我们不停地往跳表中插入数据时,如果我们不更新索引,就有可能出现某2个索引节点之间数据非常多的情况.极端情况下,跳表还会退化成单链表;

作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降;

跳表是通过随机函数来维护前面提到的平衡性.我们通过一个随机函数,来决定将这个结点插入到哪几级索引中,比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。

![image-20210810173405897](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210810173405897.png)

