#  分布式事务解决方案

# 1.分布式事务的理论

## 1.1.CAP理论

CAP理论是:**分布式系统在设计时只能在一致性(Consistency),可用性(Availability),分区容忍性(PartitionTolerance)中满足两种,无法兼顾三种**;

* **一致性(Consistency)**:服务A,B,C三个节点都存储了用户数据,三个节点的数据需要保持同一时刻数据一致性;
* **可用性(Availability):**服务A,B,C三个节点,其中一个节点宕机不影响整个集群对外提供服务;
* **分区容忍性(PartitionTolerance):**分区容忍性就是允许系统通过网络协同工作,分区容忍性要解决由于网络分区导致数据的不完整及无法访问等问题;

分布式系统能否兼顾C,A,P?

在保证分区容忍性的前提下一致性和可用性无法兼顾.如果要提高系统可用性就要增加多个节点,如果要保证数据的一致性就要实现每个节点的数据一致,节点越多可用性越好,但数据的一致性越差;

CAP的组合方式:

1. CA:放弃分区容忍性,加强一致性和可用性,关系数据库按照CA进行设计;
2. AP:放弃一致性,加强可用性和分区容忍性,追求最终一致性,很多NoSQL数据库按照AP进行设计.当然这里放弃一致性是指放弃强一致性.强一致性就是写入成功立刻要查出最新数据.追求最终一致性是指允许暂时的数据不一样,只要最终在用户接受的时间内数据一致即可.
3. CP:放弃可用性,加强一致性和分区容忍性,一些强一致性要求的系统按CP进行设计,比如跨行转账,一次转账请求要等待双方银行系统都完成整个事务才算完成.由于网络问题的存在CP系统可能会出现等待超时,如果没有处理超时问题整个系统会出现阻塞;

## 1.2.BASE理论

分布式事务处理的理论基础

BASE是Basically Available(基本可用),Soft state(软状态)和Eventual consistency(最终一致性)三个短语的缩写;

* 基本可用:可能是部分功能不可用或者是响应时间延长;
* 软状态:不同系统/节点之间,数据存在过渡状态;
* 最终一致:经过系统内部协调机制,最终所有节点保持一致;

## 1.3.强一致性和弱一致性

> * 强一致
>
>   一起行动,单个子事务操作不完全提交,等待最终提交;
>
>   当更新操作完成之后,任何多个后续进程或者线程的访问都会返回最新的更新过的值,上一次写什么,下一次就保证能读到什么.
>
> * 弱一致(最终一致性)
>
>   不保证后续进程或者线程的访问都会返回最新的更新过的值;
>
>   数据写入成功之后,不确定立即可以读到最新写入的值,也不确定多久之后可以读到,系统保证最终返回上一次更新操作的值;

## 1.4.各事务模式的对比

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210425165102459.png" alt="image-20210425165102459" style="zoom:50%;" />

# 2.强事务之Seata-AT模式

参考seata官网:http://seata.io/zh-cn/docs/dev/mode/at-mode.html

## 2.1.前提

1. 基于支持本地ACID事务的关系型数据库;
2. Java应用,通过JDBC访问数据库;

## 2.2.运行机制

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210407111958938.png" alt="image-20210407111958938" style="zoom:50%;" />

* 一阶段:业务数据和回滚日志记录在同一个本地事务中提交,释放本地锁和连接资源;
* 二阶段:
  * 提交异步化,非常快速地完成;
  * 回滚通过一阶段的回滚日志进行反向补偿;

## 2.3.工作机制

以一个示例来说明整个 AT 分支的工作过程。

业务表：`product`

| Field | Type         | Key  |
| ----- | ------------ | ---- |
| id    | bigint(20)   | PRI  |
| name  | varchar(100) |      |
| since | varchar(100) |      |

AT 分支事务的业务逻辑：

```sql
update product set name = 'GTS' where name = 'TXC';
```

### 2.3.1.一阶段

过程：

1. 解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name = 'TXC'）等相关的信息。
2. 查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。

```sql
select id, name, since from product where name = 'TXC';
```

得到前镜像：

| id   | name | since |
| ---- | ---- | ----- |
| 1    | TXC  | 2014  |

1. 执行业务 SQL：更新这条记录的 name 为 'GTS'。
2. 查询后镜像：根据前镜像的结果，通过 **主键** 定位数据。

```sql
select id, name, since from product where id = 1`;
```

得到后镜像：

| id   | name | since |
| ---- | ---- | ----- |
| 1    | GTS  | 2014  |

1. 插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 `UNDO_LOG` 表中。

```json
{
	"branchId": 641789253,
	"undoItems": [{
		"afterImage": {
			"rows": [{
				"fields": [{
					"name": "id",
					"type": 4,
					"value": 1
				}, {
					"name": "name",
					"type": 12,
					"value": "GTS"
				}, {
					"name": "since",
					"type": 12,
					"value": "2014"
				}]
			}],
			"tableName": "product"
		},
		"beforeImage": {
			"rows": [{
				"fields": [{
					"name": "id",
					"type": 4,
					"value": 1
				}, {
					"name": "name",
					"type": 12,
					"value": "TXC"
				}, {
					"name": "since",
					"type": 12,
					"value": "2014"
				}]
			}],
			"tableName": "product"
		},
		"sqlType": "UPDATE"
	}],
	"xid": "xid:xxx"
}
```

1. 提交前，向 TC 注册分支：申请 `product` 表中，主键值等于 1 的记录的 **全局锁** 。
2. 本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。
3. 将本地事务提交的结果上报给 TC。

### 2.3.2.二阶段-回滚

1. 收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。
2. 通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。
3. 数据校验：拿 UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理，详细的说明在另外的文档中介绍。
4. 根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句：

```sql
update product set name = 'TXC' where id = 1;
```

1. 提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC。

### 2.3.3.二阶段-提交

1. 收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。
2. 异步任务阶段的分支提交请求将异步和批量地删除相应 UNDO LOG 记录。

# 3.强事务之Seata-XA模式

参考seata官网:http://seata.io/zh-cn/docs/dev/mode/xa-mode.html

## 3.1.前提

* 支持XA事务的数据库;
* Java应用,通过JDBC访问数据库;

## 3.2.整体机制

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210724195340510.png" alt="image-20210724195340510" style="zoom:50%;" />

在Seata定义的分布式事务框架内,利用事务资源(数据库,消息服务等)对XA协议的支持,以XA协议的机制来管理分支事务的一种事务模式;

* 执行阶段:
  * 可回滚:业务SQL操作放在XA分支中进行,由资源对XA协议的支持来保证可回滚;
  * 持久化:XA分支完成后,执行XA prepare,同样,由资源对XA协议的支持来保证持久化(即之后任何意外都不会造成无法回滚的情况);
* 完成阶段:
  * 分支提交:执行XA分支的commit;
  * 分支回滚:执行XA分支的rollback;

## 3.3.工作机制

### 3.3.1.整体运行机制

XA模式运行在Seata定义的事务框架内:

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210724200448656.png" alt="image-20210724200448656" style="zoom:50%;" />

* 执行阶段(Execute):
  * XA start/XA end/XA prepare+SQL+注册分支;
* 完成阶段(Finish):
  * XA commit/XA rollback;

### 3.3.2.数据源代理

XA模式需要XAConnection两种方式:

* 方式一:要求开发者配置XADataSource;

  <img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210724201845087.png" alt="image-20210724201845087" style="zoom:50%;" />

* 方式二:根据开发者的普通DataSource来创建;

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210724201734144.png" alt="image-20210724201734144" style="zoom:50%;" />

### 3.3.3.分支注册

* XA start需要Xid参数;

* 这个 Xid 需要和Seata全局事务的XID和BranchId关联起来，以便由 TC 驱动 XA 分支的提交或回滚;

* 目前Seata的BranchId是在分支注册过程，由 TC 统一生成的，所以 XA 模式分支注册的时机需要在 XA start 之前;

## 3.4.XA模式的使用

编程模型上,XA模式与AT模式保持完全一致,可以参考Seata官网的样例:https://github.com/seata/seata-samples/tree/master/seata-xa;

# 4.强事务之Seata-TCC模式

参考seata官网:http://seata.io/zh-cn/docs/dev/mode/tcc-mode.html

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210724203150128.png" alt="image-20210724203150128" style="zoom:50%;" />

根据两阶段行为模式的不同,将分支事务划分为**Automatic(Branch) Transaction Mode**和**TCC(Branch) Transaction Mode**;

* AT模式基于**支持本地ACID事务**的关系型数据库;
  * 一阶段prepare行为:在本地事务中,一并提交业务数据更新和相应回滚日志记录;
  * 二阶段commit行为:马上成功结束,自动异步清理回滚日志;
  * 二阶段rollback行为:通过回滚日志,自动生成补偿朝族,完成数据回滚;
* 相应的,TCC模式,不依赖与底层的数据资源的事务支持;
  * 一阶段prepare行为:调用自定义的preapre逻辑;
  * 二阶段commit行为:调用自定义的commit逻辑;
  * 二阶段rollback行为:调用自定义的rollback逻辑;

TCC模式实际上就是自定义的分支事务纳入到全局事务管理中.

## 4.1.TCC模式的问题处理

### 4.1.1.幂等处理

#### 4.1.1.1.产生原因

因为网络抖动等原因,分布式事务框架可能会重复调用同一个分布式事务中的二阶段接口.所以分支事务的二阶段接口Confirm/Cancel需要能够保证幂等性.如果二阶段接口不能保证幂等性,则会产生严重的问题,造成资源的重复使用或者重复释放,进而导致业务故障.

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210425150431000.png" alt="image-20210425150431000" style="zoom: 80%;" />

从上图红色部分可以看到:如果当TC调用参与者的二阶段方法时,发生了异常(TC本身异常或者网络异常丢失结果).此时TC无法感知到调用结果.为了保证分布式事务能够走到终态,此时TC会按照一定的规则重复调用参与者的二阶段方法;

#### 4.1.1.2.应对策略

对于幂等类型的问题,通常的手段是引入幂等字段进行防重放攻击.对于分布式事务框架中的幂等问题,可以通过增加一张事务控制表来实现,这个表的关键字有以下几个:

1. 主事务ID;
2. 分支事务ID;
3. 分支事务状态;

其中1和2构成表的联合主键来唯一标识一笔分布式事务中的一条分支事务.3用来标识该分支事务的状态,一共有3种状态:

1. INIT-初始化;
2. CONFIRMED-已提交;
3. ROLLBACKED-已回滚;

幂等记录的插入时机是参与者的Try方法,此时的分支事务状态会被初始化为INIT.然后当二阶段的Confirm/Cancel执行时会将其状态设置为CONFIRMED/ROLLBACKED;当TC重复调用二阶段接口时,参与者会先获取事务状态控制表的对应记录查看器事务状态.如果状态已经为CONFIRMED/ROLLBACKED,那表示参与者已经处理完其分内之事,不需要再次执行,可以直接返回幂等成功的结果给TC,帮助其推进分布式事务.

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210425152454737.png" alt="image-20210425152454737" style="zoom:80%;" />

### 4.1.2.空回滚

#### 4.1.2.1.产生原因

当没有调用参与方Try方法的情况下,就调用了二阶段的Cancel方法,Cancel方法需要有办法识别出此时Try有没有执行.如果Try还没执行,表示这个Cancel操作时无效的,即本次Cancel属于空回滚;如果Try已经执行,那么执行的是正常的回滚逻辑;

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210425153057136.png" alt="image-20210425153057136" style="zoom:80%;" />

如上图所示,红色部分的一阶段Try可能失败;

首先发起方在调用参与者之前,会向TC申请开始一笔分布式事务,然后发起方调用参与者的一阶段方法,在调用实际发生前,一般会有切面拦截器感知到此次Try调用,然后写入一条分支事务记录.紧接着,在实际调用参与者的Try方法时发生了异常.异常原因可以发起方宕机,网络抖动等.触发回滚操作后,TC会对该分布式事务关联的分支事务调用其二阶段Cancel.在执行Cancel时,Try还未执行成功,触发空回滚.如果不对空回滚加以防范的话,可能会造成资源的无效释放.

#### 4.1.2.2.应对策略

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210425155154208.png" alt="image-20210425155154208" style="zoom:80%;" />

前面说过为了保证幂等性,当Try被执行成功后,会插入一条记录,标识该分支事务处于INIT状态.所以后续当二阶段Cancel方法被调用时,可以通过查询控制表的对应记录进行判断.如果记录存在且状态为INIT,就表示一阶段已成功执行,可以正常回滚操作,释放预留资源;如果记录不存在则表示一阶段未执行,本次为空回滚,不释放任何资源.

### 4.1.3.资源悬挂

#### 4.1.3.1.产生原因

考虑一种极端情况,当分布式事务到终态后,参与者的一阶段Try才被执行,此时参与者会根据业务需求预留相关资源.预留资源只有当前事务才能使用,然而此时分布式事务已经走到终态,后续再没有任何手段能够处理这些预留资源.至此,就形成了资源悬挂.

一阶段比二阶段执行的还晚的情况看似不可能,但是仔细考虑RPC调用的思绪,其实这种情况在复杂多变的网络中是完全可能的,如下:

1. 发起方通过RPC调用参与者一阶段Try,但是发生网络阻塞导致RPC超时;
2. RPC超时后,TC会回滚分布式事务(可能是发起方主动通知TC回滚或者是TC发现事务超时后回滚),调用已注册的哥参与方的二阶段Cancel;
3. 参与方空回滚后,发起方对参与者的一阶段Try才开始执行,进行预留资源从而形成悬挂;

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210425162051608.png" alt="image-20210425162051608" style="zoom:80%;" />

#### 4.1.3.2.应对策略

由于悬挂的产生背景是一阶段方法根本就未执行,所以此时事务控制记录是不存在的,需要在二阶段中处理ROLLBACK的情况,处理方案为判断为空回滚的场景下(体现在对应一阶段事务控制记录不存在),插入一条状态为ROLLBACKED的控制记录.

那么下次当一阶段Try抵达执行的时候,首先会尝试插入状态为INIT的事务控制记录,如果插入失败,表示当前分支事务的记录已经存在,Try无需继续执行.

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210425163014278.png" alt="image-20210425163014278" style="zoom:80%;" />

# 5.弱事务之Seata-Saga模式

参考seata官网:http://seata.io/zh-cn/docs/user/saga.html

## 5.1.概述

Saga模式是SEATA提供的长事务解决方案,在Sega模式中,业务流程中每个参与者都提交本地事务,当出现某个参与者失败则补偿前面已经成功的参与者,一阶段正向服务和二阶段补偿服务由业务开发实现;

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210425140359796.png" alt="image-20210425140359796" style="zoom:67%;" /> 

* 使用场景:
  * 业务流程长,业务流程多;
  * 参与者包含其它公司或遗留系统服务,无法提供TCC模式要求的三个接口;
* 优势:
  * 一阶段提交本地事务,无锁,高性能;
  * 事务驱动架构,参与者可异步执行,高吞吐;
  * 补偿服务易于实现;
* 缺点
  * 不保证隔离性

## 5.2.Saga的实现

基于状态机引擎的Saga模式是基于状态机引擎来实现的,机制是:

1. 通过状态图来定义服务调用的流程并生成json状态语言定义文件;
2. 状态图中一个节点可以是调用一个服务,节点可以配置它的补偿节点;
3. 状态图json由状态机引擎驱动执行,当出现异常时状态引擎反向执行已完成节点将事务回滚;
4. 可以实现服务编排需求,支持单项选择,并发,子流程,参数转换,参数映射,服务执行状态判断,异常捕获等功能;

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210724210917885.png" alt="image-20210724210917885" style="zoom: 33%;" />

## 5.3.最佳实践

### 5.3.1.允许空补偿

- 空补偿：原服务未执行，补偿服务执行了;
- 出现原因：
  - 原服务超时（丢包）;
  - Saga 事务触发回滚;
  - 未收到 原服务请求，先收到补偿请求;

所以服务设计时需要允许空补偿, 即没有找到要补偿的业务主键时返回补偿成功并将原业务主键记录下来;

### 5.3.2.防悬挂控制

- 悬挂：补偿服务比原服务先执行;
- 出现原因：
  - 原服务超时（拥堵）;
  - Saga 事务回滚，触发回滚;
  - 拥堵的原服务到达;

所以要检查当前业务主键是否已经在空补偿记录下来的业务主键中存在，如果存在则要拒绝服务的执行;

### 5.3.3.幂等控制

- 原服务与补偿服务都需要保证幂等性, 由于网络可能超时, 可以设置重试策略，重试发生时要通过幂等控制避免业务数据重复更新;

### 5.3.4.缺乏隔离性的应对

- 由于 Saga 事务不保证隔离性, 在极端情况下可能由于脏写无法完成回滚操作, 比如举一个极端的例子, 分布式事务内先给用户A充值, 然后给用户B扣减余额, 如果在给A用户充值成功, 在事务提交以前, A用户把余额消费掉了, 如果事务发生回滚, 这时则没有办法进行补偿了。这就是缺乏隔离性造成的典型的问题, 实践中一般的应对方法是：
  - 业务流程设计时遵循“宁可长款, 不可短款”的原则, 长款意思是客户少了钱机构多了钱, 以机构信誉可以给客户退款, 反之则是短款, 少的钱可能追不回来了。所以在业务流程设计上一定是先扣款;
  - 有些业务场景可以允许让业务最终成功, 在回滚不了的情况下可以继续重试完成后面的流程, 所以状态机引擎除了提供“回滚”能力还需要提供“向前”恢复上下文继续执行的能力, 让业务最终执行成功, 达到最终一致性的目的;

# 6.本地消息表

1. A系统在自己本地一个事务中操作同时插入一条数据到消息表;
2. 接着系统A系统将这个消息发送到MQ中去;
3. B系统接收到消息之后,在一个事务中,往自己本地消息表里插入一条数据,同时执行其他的业务操作,如果这个消息已经被处理过了,那么此时这个事务会回滚,这样保证不会重复处理消息;
4. B系统执行成功之后,就会更新自己本地消息表的状态以及发送消息或通过Zookeeper去更新系统A消息表的状态;
5. 如果B系统处理失败了,那么就不会更新消息表的状态,那么此时A系统会定时扫描自己的消息表,如果有没处理的消息,通过定时任务发送到MQ中去,让B再次处理;
6. 这个方案保证了最终一致性,哪怕B事务失败了,但是A会不断重发消息,直到B成功.

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210724222725168.png" alt="image-20210724222725168" style="zoom:50%;" />

# 7.可靠消息最终一致性方案

1. A系统先发送一个prepared消息到MQ,如果这个prepared消息发送失败那么就直接取消操作不执行;
2. 如果这个消息发送成功了,那么久接着执行本地事务,如果成功了就告诉MQ发送确认消息,如果失败就告诉MQ回滚消息;
3. 如果发送了确认消息,那么此时B系统就会接收到确认消息,然后执行本地事务;
4. MQ会自动定时轮询所有prepared消息回调接口,问这个消息是不是本地事务失败了,所以没有发送确认消息,那么是继续重试还是回滚?如果本地回滚了,这里也回滚.这个就是避免可能本地事务执行成功了,确认消息发送失败了;
5. B系统的事务失败了就会重试,B系统本地回滚后,通知A也回滚;

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210724223650126.png" alt="image-20210724223650126" style="zoom:50%;" />

# 8.最大努力通知方案

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210724225036602.png" alt="image-20210724225036602" style="zoom:50%;" />

1. 系统A本地事务执行完成后,发送消息到MQ;
2. 这里有个专门消费MQ的最大努力通知服务,这个服务会消费MQ然后写入数据库中记录下来;接着调用系统B的接口;
3. 要是系统B执行成功了就OK了,要是系统B执行失败了,那么最大努力通知服务就定时尝试重新调用系统B,反复N次,最后还是不行就放弃;

# 9.分布式事务之消息机制

可以通过消息队列来实现类似于TCC和Saga的分布式事务的方案.

如下图:如果使用`order_commit`这个Queue,那么思路就类似于Saga;如果使用了`order_commit`,思路就类似于TCC; 

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210425164618524.png" alt="image-20210425164618524" style="zoom: 67%;" />

#10.分布式事务有必要在分布式架构中全盘通用?

99%的分布式接口调用,不要做分布式分布式事务,因为加了分布式事务代码太复杂,性能太差.一般我们直接做监控代码报错(发邮件,发短信),记录日志,事后快速定位,排查和出解决方案,修复数据.

